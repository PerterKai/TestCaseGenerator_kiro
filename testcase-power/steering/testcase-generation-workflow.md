---
inclusion: manual
---

# 测试用例生成工作流

## 完整工作流程（分阶段，支持跨 session 恢复）

### 阶段0: 进度恢复（新 session 必做）
1. 调用 `get_workflow_state` 检查是否有已保存的工作流
2. 如果有未完成的工作，按返回的 resume 指令继续
3. 如果没有，从阶段1开始

### 阶段1: 文档转换与图片处理
1. 使用 `parse_documents` 将工作区中所有 `.docx` 文件转换为 Markdown
   - Markdown 文件输出到 `.tmp/doc_mk/` 目录
   - 图片提取到 `.tmp/picture/` 目录
   - 状态缓存到 `.tmp/cache/` 目录
2. 逐一处理每张图片（每次只处理一张）：
   a. 调用 `get_pending_image` 获取下一张待处理图片
   b. 模型自动判断图片类型，从测试视角提取具体内容：
      - 数据表/字段定义 → 逐行提取：字段名、类型、长度、必填、默认值、描述
      - 流程图/状态图 → 列出所有节点、转换条件、每条分支路径
      - ER图/架构图 → 列出所有实体、属性、关系、外键
      - UI截图/原型图 → 列出表单字段、按钮、下拉选项、表格列头
      - 接口/参数定义 → 逐个提取参数名、类型、必填、取值范围、描述
   c. 调用 `submit_image_result(image_id, analysis)` 提交结果
   d. 重复直到所有图片处理完毕
   
   **跨 session 恢复**: 所有图片处理进度自动持久化到 `.tmp/cache/`。
   如果系统触发新 session，在新会话中调用 `get_workflow_state` 即可恢复进度继续处理。
   
   **核心原则：提取具体数据，禁止笼统概括。**

### 阶段2: 测试用例生成（建议新 session）
图片处理完成后，建议开启新 session 进行用例生成，以获得最大上下文空间。

1. 调用 `get_workflow_state` 恢复进度
2. 调用 `get_doc_summary` 获取文档结构概览（标题树 + 字数统计）
3. 按模块分批生成用例：
   a. 调用 `get_doc_section(doc_name, section_heading)` 读取一个模块的内容
   b. 基于该模块内容生成测试用例
   c. 调用 `save_testcases(append_module=该模块的完整JSON对象)` 增量保存该模块用例
      - **必须传递 `append_module` 参数**（单个模块对象，非数组），不能省略
      - 示例：`save_testcases(append_module={"name":"模块名","sub_modules":[...]})`
   d. 重复处理下一个模块
4. 所有模块追加完毕后，调用 `get_testcases` 确认用例完整性

**避免使用 `get_parsed_markdown` 一次性加载全部文档内容！**
优先使用 `get_doc_summary` + `get_doc_section` 分段读取。

用例结构：
```json
{
  "modules": [
    {
      "name": "模块名称",
      "sub_modules": [
        {
          "name": "子模块名称",
          "test_cases": [
            {
              "title": "用例标题",
              "preconditions": "前置条件",
              "steps": ["步骤1", "步骤2"],
              "expected_result": "预期结果"
            }
          ]
        }
      ]
    }
  ]
}
```

XMind 导出层级（链式嵌套，每层单子节点）：
```
测试用例 (root)
  └─ 模块
      └─ 子模块
          └─ 用例标题
              └─ 前置条件: xxx
                  └─ 执行步骤: 1. xxx \n 2. xxx
                      └─ 预期结果: xxx
```

生成维度：
- 正向功能: 核心业务流程的正常执行
- 边界条件: 最大值、最小值、空值、特殊字符
- 异常处理: 网络异常、超时、权限不足、数据不存在
- 安全性: 认证、授权、数据加密、SQL注入、XSS
- 性能: 并发、大数据量、响应时间
- 兼容性: 不同设备、不同版本、不同状态

### 阶段2.5: 模块结构审查
用例初步生成完毕后，进入模块结构审查：

1. 调用 `review_module_structure` 获取模块结构审查报告
2. 根据报告中的问题和建议，调整模块划分：
   - 过大的模块（>15个用例的子模块）按场景拆分
   - 过小的模块（只有1个用例的子模块过多时）合并相关子模块
   - 修正空模块、重复命名等问题
   - 补充缺失的前置条件、步骤、预期结果
3. 调整后调用 `save_testcases(modules=调整后的全部用例数组)` 保存
4. 可再次调用 `review_module_structure` 确认调整效果

### 阶段3: 自动Review
对生成的用例进行自我审查：

1. 调用 `get_testcases` 获取当前所有用例
2. 按以下检查清单逐项审查：
   - 覆盖完整性: 文档中提到的每个功能点是否都有对应用例？
   - 图片覆盖: 流程图中的每条路径、状态图中的每个转换是否都有用例？
   - 边界充分性: 每个输入字段是否考虑了边界值？
   - 异常覆盖: 每个操作是否考虑了失败场景？
   - 步骤可执行性: 每个步骤是否清晰、可操作？
   - 预期结果明确性: 预期结果是否具体、可验证？
3. 发现问题后，修改用例并调用 `save_testcases(modules=修改后的全部用例数组)` 保存
   - Review 阶段使用 `modules` 参数（完整用例数组）进行全量替换保存
4. 重复步骤 1-3，迭代 2-3 轮
5. **在 Review 过程中，记录发现的需求疑问点和确认项**，用于最终报告

### 阶段4: 导出
自动 Review 完成后：
1. 调用 `export_xmind` 导出 XMind 文件（自动命名为 `需求名_testCase.xmind`）
2. 调用 `export_report(questions=[...])` 导出测试报告（自动命名为 `需求名_testCaseReport.md`）
   - `questions` 参数传入 Review 过程中发现的需求疑问点列表
   - 报告与 XMind 文件在同一目录下

## 注意事项
- 对文档中的专业术语保持原样，不要随意翻译或替换
- 表格中的字段约束应转化为具体的测试用例
- 状态机/流程图中的每条路径都应有对应的测试用例
- 接口文档中的每个参数都应有正向和反向测试
- 图片分析结果已直接写入 Markdown 文件，生成用例时注意上下文关联
- 接口的业务规则（如删除前校验关联数据、状态流转限制）是用例设计的核心依据
- 每个用例的预期结果必须包含具体的返回值或错误提示文案，不能用"操作失败"等模糊描述
- 前置条件必须明确数据状态，如"存在状态为0-Building的站点，已配置计费规则"
- 步骤中涉及接口调用时，需明确请求方式、路径和关键参数
- `save_testcases` 的 `append_module` 参数必须是单个模块对象（非数组），`modules` 参数必须是数组

## 图片分析质量标准

### 合格的分析示例（数据表截图）：
```
| 字段名 | 类型 | 长度 | 必填 | 默认值 | 描述 |
|--------|------|------|------|--------|------|
| station_id | VARCHAR | 64 | 是 | - | 站点唯一标识 |
| station_name | VARCHAR | 128 | 是 | - | 站点名称 |
```

### 不合格的分析示例：
```
数据表结构定义截图 - 展示了数据库表的字段列表，包含字段名、数据类型等。
```
这种概括性描述对测试用例设计毫无帮助。
