---
inclusion: manual
---

# 测试用例生成工作流

## 完整工作流程（分阶段，支持跨 session 恢复）

### 阶段0: 环境检查与任务决策（每次启动必做）

1. 调用 `setup_environment` 执行启动检查
2. 工具自动完成：依赖检查 → 目录创建 → 缓存任务检测
3. 根据返回结果决定后续流程：

**如果 `has_cache=true`（检测到缓存任务）：**
- 向用户展示缓存任务详情（阶段、图片进度、用例数量）
- 询问用户选择：
  - "继续上次任务" → 调用 `get_workflow_state` 恢复进度，按 resume 指令继续
  - "开始新任务" → 调用 `clear_cache` 清除缓存，进入阶段1

**如果 `has_cache=false`（无缓存）：**
- 直接进入阶段1

### 阶段1: 确认文档与选择处理模式（新任务时）

#### 1.1 确认文档就位
向用户确认文档已放入 `doc/` 目录：
- 需求文档（.docx）
- 概要设计文档（.docx）

等待用户明确确认后再继续。

#### 1.2 选择处理模式
向用户说明两种模式：

| 模式 | 说明 | tokens 消耗 |
|------|------|-------------|
| 文档+图片模式 | 解析文字+图片，图片通过AI视觉逐一分析 | 高 |
| 文档模式 | 仅解析文字内容，跳过图片分析 | 低 |

- 用户选择"文档+图片模式" → 执行阶段2 + 阶段2.5（图片处理）
- 用户选择"文档模式" → 执行阶段2，跳过阶段2.5，直接进入阶段3

### 阶段2: 文档转换
1. 使用 `parse_documents` 将工作区中所有 `.docx` 文件转换为 Markdown
   - Markdown 文件输出到 `.tmp/doc_mk/` 目录
   - 图片提取到 `.tmp/picture/` 目录
   - 状态缓存到 `.tmp/cache/` 目录

### 阶段2.5: 图片处理（仅"文档+图片模式"）
逐一处理每张图片（每次只处理一张）：
   a. 调用 `get_pending_image` 获取下一张待处理图片
   b. 工具返回包含 base64 图片数据的 image content 和图片的工作区相对路径（`image_path` 字段）
   c. 如果能直接看到图片（MCP image content 被正确传递），直接分析图片内容
   d. 如果看不到图片（只收到文本），通过返回的 `image_path`（如 `.tmp/picture/xxx.png`）读取图片文件进行分析
   e. 模型自动判断图片类型，从测试视角提取具体内容：
      - 数据表/字段定义 → 逐行提取：字段名、类型、长度、必填、默认值、描述
      - 流程图/状态图 → 列出所有节点、转换条件、每条分支路径
      - ER图/架构图 → 列出所有实体、属性、关系、外键
      - UI截图/原型图 → 列出表单字段、按钮、下拉选项、表格列头
      - 接口/参数定义 → 逐个提取参数名、类型、必填、取值范围、描述
   f. 调用 `submit_image_result(image_id, analysis)` 提交结果
   g. 重复直到所有图片处理完毕

   **跨 session 恢复**: 所有图片处理进度自动持久化到 `.tmp/cache/`。
   如果系统触发新 session，在新会话中调用 `setup_environment` 即可检测缓存并恢复进度。
   
   **核心原则：提取具体数据，禁止笼统概括。**

### 阶段3: 测试用例生成（建议新 session）
图片处理完成后，建议开启新 session 进行用例生成，以获得最大上下文空间。

1. 调用 `setup_environment` → 检测到缓存 → 用户选择"继续" → 调用 `get_workflow_state` 恢复进度
2. 调用 `get_doc_summary` 获取文档结构概览（标题树 + 字数统计）
3. 按模块分批生成用例：
   a. 调用 `get_doc_section(doc_name, section_heading)` 读取一个模块的内容
   b. 基于该模块内容生成测试用例
   c. 调用 `save_testcases(append_module=该模块的完整JSON对象)` 增量保存该模块用例
      - **必须传递 `append_module` 参数**（单个模块对象，非数组），不能省略
      - 示例：`save_testcases(append_module={"name":"模块名","sub_modules":[...]})`
   d. 重复处理下一个模块
4. 所有模块追加完毕后，调用 `get_testcases` 确认用例完整性

**避免使用 `get_parsed_markdown` 一次性加载全部文档内容！**
优先使用 `get_doc_summary` + `get_doc_section` 分段读取。

用例结构：
```json
{
  "modules": [
    {
      "name": "模块名称",
      "sub_modules": [
        {
          "name": "子模块名称",
          "test_cases": [
            {
              "title": "用例标题",
              "preconditions": "前置条件",
              "steps": ["步骤1", "步骤2"],
              "expected_result": "预期结果"
            }
          ]
        }
      ]
    }
  ]
}
```

XMind 导出层级（链式嵌套，每层单子节点）：
```
测试用例 (root)
  └─ 模块
      └─ 子模块
          └─ 用例标题
              └─ 前置条件: xxx
                  └─ 执行步骤: 1. xxx \n 2. xxx
                      └─ 预期结果: xxx
```

生成维度：
- 正向功能: 核心业务流程的正常执行
- 边界条件: 最大值、最小值、空值、特殊字符
- 异常处理: 网络异常、超时、权限不足、数据不存在
- 安全性: 认证、授权、数据加密、SQL注入、XSS
- 性能: 并发、大数据量、响应时间
- 兼容性: 不同设备、不同版本、不同状态

### 阶段3.5: 模块结构审查
用例初步生成完毕后，进入模块结构审查：

1. 调用 `review_module_structure` 获取模块结构审查报告
2. 根据报告中的问题和建议，调整模块划分：
   - 过大的模块（>15个用例的子模块）按场景拆分
   - 过小的模块（只有1个用例的子模块过多时）合并相关子模块
   - 修正空模块、重复命名等问题
   - 补充缺失的前置条件、步骤、预期结果
3. 调整后对需要调整的模块逐个调用 `save_testcases(append_module=调整后的单个模块对象)` 保存
4. 可再次调用 `review_module_structure` 确认调整效果

### 阶段4: 自动Review
对生成的用例进行自我审查：

1. 调用 `get_testcases` 获取当前所有用例
2. 按以下检查清单逐项审查：
   - 覆盖完整性: 文档中提到的每个功能点是否都有对应用例？
   - 图片覆盖: 流程图中的每条路径、状态图中的每个转换是否都有用例？
   - 边界充分性: 每个输入字段是否考虑了边界值？
   - 异常覆盖: 每个操作是否考虑了失败场景？
   - 步骤可执行性: 每个步骤是否清晰、可操作？
   - 预期结果明确性: 预期结果是否具体、可验证？
3. 发现问题后，对需要修改的模块逐个调用 `save_testcases(append_module=修改后的单个模块对象)` 保存
   - **Review 阶段也使用 `append_module` 逐模块更新**，按模块名自动替换已有同名模块
   - 不需要修改的模块无需重新提交，避免全量提交导致参数截断
4. 重复步骤 1-3，迭代 2-3 轮
5. **在 Review 过程中，记录发现的需求疑问点和确认项**，用于最终报告

### 阶段5: 导出
自动 Review 完成后：
1. 调用 `export_xmind` 导出 XMind 文件（自动命名为 `需求名_testCase.xmind`）
2. 调用 `export_report(questions=[...])` 导出测试报告（自动命名为 `需求名_testCaseReport.md`）
   - `questions` 参数传入 Review 过程中发现的需求疑问点列表
   - 报告与 XMind 文件在同一目录下

## 注意事项
- 对文档中的专业术语保持原样，不要随意翻译或替换
- 表格中的字段约束应转化为具体的测试用例
- 状态机/流程图中的每条路径都应有对应的测试用例
- 接口文档中的每个参数都应有正向和反向测试
- 图片分析结果已直接写入 Markdown 文件，生成用例时注意上下文关联
- 接口的业务规则（如删除前校验关联数据、状态流转限制）是用例设计的核心依据
- 每个用例的预期结果必须包含具体的返回值或错误提示文案，不能用"操作失败"等模糊描述
- 前置条件必须明确数据状态，如"存在状态为0-Building的站点，已配置计费规则"
- 步骤中涉及接口调用时，需明确请求方式、路径和关键参数
- `save_testcases` 的 `append_module` 参数必须是单个模块对象（非数组），`modules` 参数必须是数组
- **始终优先使用 `append_module` 逐模块保存**，`modules` 全量替换仅在模块极少时使用，大量用例时会因参数过大导致截断失败

## 图片分析质量标准

### 合格的分析示例（数据表截图）：
```
| 字段名 | 类型 | 长度 | 必填 | 默认值 | 描述 |
|--------|------|------|------|--------|------|
| station_id | VARCHAR | 64 | 是 | - | 站点唯一标识 |
| station_name | VARCHAR | 128 | 是 | - | 站点名称 |
```

### 不合格的分析示例：
```
数据表结构定义截图 - 展示了数据库表的字段列表，包含字段名、数据类型等。
```
这种概括性描述对测试用例设计毫无帮助。
